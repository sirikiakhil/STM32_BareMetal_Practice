// main.c

#include "SPI.h"

static void led_config_spimode(void);

/************************************************************/

int main(void)
{


	//Configure GPIO pins for SPI1 and SPI2
	spi1_gpio_config();
	spi2_gpio_config();


	//Configure SPI peripherals
	spi1_config();   //SPI1 as MASTER
	spi2_config();   //SPI2 as SLAVE


	//Configure LED pin
	led_config_spimode();


	//Transmit data from SPI1 (MASTER)
	uint8_t spi1_tx_data[3] = {0x77, 0x88, 0x99};

	//Receive buffers
	uint8_t spi2_rx_data[3];   //Data received by SPI2 (SLAVE)
	uint8_t spi1_rx_data[3];   //Dummy data received by SPI1 (MASTER)


	SPI2->DR = 0xAA;   // Dummy preload


	/*
		*CS is enabled here as good SPI practice, In this project, SPI2 uses Software NSS (SSM + SSI)
		*so, CS is not strictly required for SPI2 to work.
	*/
	cs_enable();



	for(uint8_t i = 0; i < 3; i++)
	{


		//Wait until SPI1 transmit buffer is empty
		while(!(SPI1->SR & SPI_SR_TXE)){}

		// Write data to SPI1 data register
		//This also generates clock for SPI2
		SPI1->DR = spi1_tx_data[i];

		//Wait until SPI2 receives data
		while(!(SPI2->SR & SPI_SR_RXNE)){}

		//Read received data from SPI2
		spi2_rx_data[i] = SPI2->DR;

		//SPI is full duplex so, SPI1 also receives data
		while(!(SPI1->SR & SPI_SR_RXNE)){}

		//Read dummy data received by SPI1
		spi1_rx_data[i] = SPI1->DR;
	}

	cs_disable();

	// Wait until SPI1 is no longer busy
	while(SPI1->SR & SPI_SR_BSY){}



	/*
		OVR (Overrun) safety clear.
		Reading DR followed by SR clears possible OVR flag.
		This is defensive coding for future scalability.
	*/
    volatile uint8_t temp;
	temp = SPI1->DR;
	temp = SPI1->SR;

	temp = SPI2->DR;
	temp = SPI2->SR;

	while(1)
	{
		/*
			Simple verification:
			If transmitted data matches received data,
			turn ON LED.
		*/
		for(uint8_t i = 0; i < 3; i++)
		{
			if(spi1_tx_data[i] == spi2_rx_data[i])
			{
				GPIOA->ODR |= (1U << 9);
				for(uint32_t j = 0; j < 200000; j++);
				GPIOA->ODR &= ~(1U << 9);
			}
		}

		for(uint32_t i = 0; i < 2000000; i++);
	}
}

/************************************************************/

static void led_config_spimode(void)
{
	// Configure PA9 as output (LED)
	GPIOA->MODER &= ~(3U << 18);
	GPIOA->MODER |=  (1U << 18);
}
