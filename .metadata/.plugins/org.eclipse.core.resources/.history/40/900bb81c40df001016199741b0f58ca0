/*
 * Measuring button press duration using timer counter
 */
#include "stm32f4xx.h"
#include <stdio.h>
#include "core_cm4.h"

#define HIGH 1
#define LOW  0

volatile uint32_t num_of_over_flows;   //declaring global variable ( we can't use static to this in isr )

static void gpio_config(void);
static void timer_config(void);
static void cal_fun(void);
static void nvic_config(void);

void SWV_Init(void)
{
    /* Enable trace */
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;

    /* Unlock ITM */
    ITM->LAR = 0xC5ACCE55;

    /* Enable ITM and SWO */
    ITM->TCR =
          ITM_TCR_ITMENA_Msk |
          ITM_TCR_SWOENA_Msk;

    /* Enable stimulus port 0 */
    ITM->TER |= (1UL << 0);
}

int main(void)
{
    SystemCoreClockUpdate();   // already in your project
    SWV_Init();                //  MUST be here, ONCE

    gpio_config();             //configuring of GPIO
    timer_config();            //configuration of Timer

    uint8_t curr_state;
    uint8_t prev_state =  HIGH;
    while (1)
    {
       curr_state = (((GPIOC->IDR) >> 13) & 1);
       //for(volatile uint32_t num= 0;num<20000;num++);     //debounce

       // FALLING EDGE - button pressed
       if ((prev_state == HIGH) && (curr_state == LOW))
          {
              TIM2->SR &= ~TIM_SR_UIF;     // clear update flag
              TIM2->CNT = 0;              // reset counter
              TIM2->CR1 |= TIM_CR1_CEN;   // start timer
          }

          //RISING EDGE - button released
          else if ((prev_state == LOW) && (curr_state == HIGH))
          {
              TIM2->CR1 &= ~TIM_CR1_CEN;  // stop timer
              cal_fun();                  // calculate & printing
          }
       prev_state = curr_state;           ////with respect to time it change state (after pressing the button)
    }
}

static void gpio_config(void)
{
	// GPIOC is on AHB1 bus
	RCC->AHB1ENR |=RCC_AHB1ENR_GPIOCEN ;      //Enableing the clock for GPIOA
	(void)RCC->AHB1ENR;                       // read-back to ensure clock is active

	GPIOC->MODER &= ~(3U << 26);             //Clearing the moder PC13 bits to config as input mode

	GPIOC->OSPEEDR &= ~(3U << 26);           //Clearing the output speed PC13 bits to set  low speed

    GPIOC->PUPDR &= ~(3U << 26);            //Clearing the PC13 PUPDR bits
	GPIOC->PUPDR |= (1U << 26);             // config as pull-up
}

static void timer_config(void)
{
	// TIMER is on APB1 bus
	RCC->APB1ENR |=RCC_APB1ENR_TIM2EN ;      //Enableing the clock for TIMER2
	(void)RCC->APB1ENR;                      // read-back to ensure clock is active

	TIM2->CR1 &= ~(TIM_CR1_CEN);              //Disabling the timer to configure the prescaler & ARR ....

	TIM2->PSC = 15999;                       //setting the Prescaler ( 1000Hz for clock 16MHz)

	TIM2->ARR = 100000;                      //setting the ARR

	TIM2->DIER |= (TIM_DIER_UIE);            //Enabling the interrupt mode

	TIM2->SR &= ~(TIM_SR_UIF);              //Clearing the SR UIF flag

	TIM2->CNT = 0;                          //reseting the counter register manually

	nvic_config();             //configuratio of NVIC
}

static void nvic_config(void)
{
	NVIC->ISER[0] |= (1U << 28);              //setting the ISER register 28th position or 28th interrupt (TIM2 Interrupt)

	NVIC->IP[28] &= ~(16U << 4);             //clearing the IPR[28] register of offset 0
	NVIC->IP[28] |= (1 << 4);              //setting the IPR[28] register of offset 0
}

static void cal_fun(void)
{
	uint32_t count = TIM2->CNT;

	double float sec = (((num_of_over_flows * 100000) + count) / 1000);
	printf("Total seconds Pressed = %lf ",sec);

	TIM2->CNT = 0;                          //reseting the counter register manually
	num_of_over_flows = 0;                  //reseting the overflow count
}

void TIM2_IRQHandler(void)
{
	TIM2->SR &= ~(TIM_SR_UIF);              //Clearing the SR UIF flag
	num_of_over_flows++;
}
